- 流水账 - 记录自己这个小时做了什么（便于“从外面”直接查看这个小时的学习内容）
- 想法 - 记录自己这个小时的感悟（便于再次看这里的时候，可以接着进行更深层的思考感悟）

---

# H1

## 流水账

- 概览 chap1-3
- 读 chap1
- 精读 chap1.1

# H2

## 流水账

- exer1.1-1.5
- 项目上传 github

# H3

## 流水账

- 精读部分 chap1.6

# H4

## 流水账

- 用 cond 实现 if
- exer1.7 做了一半

## 想法

- exer1.6 🤷‍♂️
- 前面的问题还没有思考的很透彻

# H5

## 流水账

- exer1.8
- 精读部分 chap1.8

## 想法

状态不太好，看着教材思路总是乱跑，理解能力很糟

# H6

## 流水账

- chap1.2, chap1.2.1

## 想法

本章讲解一些常见的“套路”，以及对应的时空复杂度。

"visualize the consequences of the actions"(I should know the result of the action I am about to take.)

The example is computation of a factorial function.(both in recursive process and iterative process)

# H7

## 流水账

- exer1.9
- exer1.10

# H8

## 流水账

- 重温 chap1.1.2

## 想法

因为我在做题的时候感觉还是有点吃力，感觉不舒服，而这的原因在于我的“基础不够扎实”。因此我想再从头学习，这次的目的就是将基础弄的足够扎实。让我思维行进的时候充满安全感。

# H9

## 流水账

- 重温 chap1.1.3-1.1.5

## 想法

```scheme
; 手写了一次 evaluate 过程
; 从最左最外开始，逐渐先把树构造出来
; 然后对树中的？进行运算，因为最外面的节点是确定的，因此可以逐步算出来所有节点的值，于是可以得到整个expression的值
; eval 结束
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

eval 的方式本身就和语言的语法关系非常密切。

而 lisp 的语法非常简单，一个 general rule 和几个 special rule 便足够。

目前又增加了“声明函数”的功能，且利用 substitution model 可以去手动 interprete 一个程序。

# H10

## 流水账

- chap1.1 全部重温完毕

## 想法

目前学到的就是从 math expression 转换为 program expression(scheme expression)

算是把 scheme 中最基础一部分的语法以及对应 eval 有更加详细的理解。

当我非常明确某个语法的各个细节的 eval，那么我使用的时候就不会轻易出错，更不会出现思维模糊混乱，最多也就是想不出来办法，而这是另外的问题。

# H11

## 流水账

- 重温 chap1.2.1

## 想法

对 linear 的 recursion 和 iteration 有更直观的感觉了吧。。

**感觉自己确实是在思考，只是这时间真的是刷刷的溜走...**

# H12

## 流水账

- 重温 chap1.2.2

- exer1.11

## 想法

虽然例子比较简单，习题也同样。但是，如果不用正确的思考方式，看这些做这些，对我的提升也比较小。

正确的思考方式是，将问题成功拆解为一些小问题，而将这些小问题利用自己所掌握的一一实现，最终实现了原问题。

然后，将之变得“自然直观”，掌握之。

也因此，这一个小时，我也没法全面掌握 tree recursion，因此没法继续往下走。

# H13

## 想法

其实这个小时我是在自己不看课本的总结，只是总是因为感觉自己进度太慢的原因，不想将这一个小时作数。

还是记上吧。。。毕竟是集中时间在思考 sicp 的主题

# H14

## 流水账

- exer1.12

## 想法

为什么进度这么慢？，因为我意识到了我基础的问题，并针对调整我的学习方式。

像数学等等领域，基础足够扎实尤其重要。即，对用于组成当前问题的“更微观一点的问题”的掌握要足够好。

不过确实，其实这里依然是有「思维陷阱」的，就像海淀驾校老师跟我们说的，“寻思可以，但别寻思的太多太深”。寻思多了反而在有限的时间内可能取得的结果反而不够好，尽管这里确实可能潜藏着什么道理规律。

「打基础」就是慢，如果进展顺利的话，与「囫囵吞枣」的策略相比是“先慢后快”，而且“上限高很多”（甚至猜测这个上限受灵感/自己的寿命限制，如果寿命悠久一直这么扎实的积累下去。。。）

当然随着生活/学习的不断进行，基础也会不断的被「优化」，变得更加优秀可靠牢固。

**学习不是旅游打卡，不是说看完、做完就拉倒，而是真的要 “掌握”。**

**没有吸收，仅仅有种熟悉感，大多数时候约等于没用，也就意味着这段时间基本浪费掉了**

### exer1.13(TODO)

我的思路是通过相减小与 0.5，但是问题在于是无穷的，所以是不行的

题目的提示，就算我最后证明了那个，又和题目是什么关系...?

# H15

## 流水账

- chap1.2.3

## 想法

chap1.2.3

order of growth is about the size of the input, the steps that required to solve this problem, and the space that needed when the size of the input grows.

看了一些 chap1.2.2 上面的 example（因为 exer1.14 基于这个，之前因为是英文应用题，没看..）

所以说，其实这些算法/计算问题，首先应该是讲问题定义清楚，然后思考清楚将至洞察找到计算的方向，然后将方向从模糊到具体实现，写成 recursive 的代码让计算机去“遍历所有可能性”。

将某金额破开，一共有五种可用的面额。通过**观察和思考**得出方案，那可能存在的情况可以看作是两者相加，一是不用某一种面额破开的可能性数量加上，一定必须要用某一种面额将至破开的所有可能性（而这又等于用一次这种面额，将剩余的金额再用 5 种破开）。然后沿着此方向下去，最终会到特殊情况，比如 0 种面额，0 金额甚至负数，这些特殊情况可以直接得出一个值，将这些值“归”回去，结果可得。

# H16

**暂时略过** chap1.2.4 - 1.2.6。这几章讲算法指标，以及一些例子和习题，等我具体学习算法的时候，参考着再看。

**暂时略过** chap1.3

## 流水账

浏览 chap1.3

## 想法

十多分钟就能过完 chap1.3 整个子章节，它讲的内容我非常清楚，那就是“一个函数可以当作另一个函数的输入或者是输出，这个机制可以用来建立‘更高的抽象规则’”

chap1.3.1 先将相关性不那么高的细节省略，突出描述将函数作为输入的感觉

chap1.3.2 介绍 lisp 中相关的语法，从使用 lisp 的角度来扩展上一章

chap1.3.3 介绍这种机制的应用场景

chap1.3.4 再进行扩展，介绍返回一个函数的情况

每一个小 chap 都应该可以被积累为几个基本功，这样在日常编程就能用了

我不看前面 1.2.4 以后，是因为工作上确实用不上算法，而高阶函数，其实目前也是用不上的

所以，准确来说，应该是**概念我都懂得一些，但是没有关于这些概念的非常踏实牢固的积累**，导致自己写代码时灵时不灵。

# H17

## 流水账

看完目录和所有章节的序言

## 想法

“感觉自己学习速度太慢了”这个想法一直折磨着我，导致我这个小时在读目录（似乎将目录都读完能等于某种意义上将这本书读完一样）

不过，还有一个好消息：我终于能将目录上，以及每章节的序言都“读懂”了。虽然和第一章类似，对各个具体情况没有详细掌握，但是高层次的概念和道理都是很明确的。

chap1 介绍编程语言最基本的元素，以及基础的 eval 模型（substitution model）。介绍“过程抽象”。介绍最常用的模式（iter recurse）。介绍程序复杂度分析(order of growth)。介绍一个强力语言特性，高阶函数。

chap2 介绍“数据抽象”，从简单数据变成了复杂的数据。

chap3 介绍“基于对象”和“基于流”的两种“编程思想”

chap4 转变角色为设计语言、实现语言特性的人。利用 scheme 提供的 meta lang 的特性

chap5 虽然 lisp 很灵活，但毕竟还是有一些限制。本章深入更底层，抽象并实现一个指令执行机器

# H18

## 流水账

进行一次总结

## 想法

使用编程语言“书写”源代码，是写给某另一个程序“看”的。

# H19

## 流水账

- chap1.2.2-example
- exer1.14

## 想法

自己思维应该能够使用 substitution model 去 evaluate expression

# H20

## 流水账

- exer1.15

## 想法

1.2 章的重点常见的“套路”，以及 order of growth

我应该学到：对代码能够 visualize 的能力。基于这个能力，还应再学到评估当前程序的 order of growth。

计算同样的结果，使用的算法不同，order of growth 就可能不同。比如 recursion 和 iteration 两种方式去计算 n!

设计整体代码的时候，可以先定义明确一个过程的输入、输出，以及这个过程“是做什么的”。当前，暂不需要考虑里面怎么实现。由于每个过程都如此的定义清晰了，那么这些过程之间应该可以组合，体现出更宏观的作用，乃至实现目标。

# H21

## 流水账

- chap1.3.1

## 想法

`(define (cube x) (* x x x))` is an abstraction that can calculate the cube of any number.

"Sigma notation" in math is an analogy to a higher order procedure.

从 sigma notation 再进一步，到 积分 notation

**higher order procedure = "template" + "slots"**

# H22

## 流水账

- chap1.3.2

## 想法

scheme 中，【声明】是一个关键词(define)，不像是 js(function, var, let...)。到这章节，加入了 lambda 形式，因此

```scheme
(define (someProcedure a) (+ a 1))

(define someProcedure (lambda (a) (+ a 1))); 相当于将直接define声明函数，“拆分”开两部分，“名字”和“其余部分”

((lambda (a) (+ 1 a)) 1); scheme的【匿名函数自执行】写法
```

学到了 let 语法的由来。原来是 lambda 的一个使用场景（local variables）下的语法糖（通过使用 let 形式，和正常写数学式子更像）。

自己过了几遍例子。

学会了一种写法形式，比如：`<body(斜体)>（高尖括号）`，代表着：“作用是 body”
