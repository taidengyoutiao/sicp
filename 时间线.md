- 流水账 - 记录自己这个小时做了什么（便于“从外面”直接查看这个小时的学习内容）
- 想法 - 记录自己这个小时的感悟（便于再次看这里的时候，可以接着进行更深层的思考感悟）

---

# H1

## 流水账

- 概览 chap1-3
- 读 chap1
- 精读 chap1.1

# H2

## 流水账

- exer1.1-1.5
- 项目上传 github

# H3

## 流水账

- 精读部分 chap1.6

# H4

## 流水账

- 用 cond 实现 if
- exer1.7 做了一半

## 想法

- exer1.6 🤷‍♂️
- 前面的问题还没有思考的很透彻

# H5

## 流水账

- exer1.8
- 精读部分 chap1.8

## 想法

状态不太好，看着教材思路总是乱跑，理解能力很糟

# H6

## 流水账

- chap1.2, chap1.2.1

## 想法

本章讲解一些常见的“套路”，以及对应的时空复杂度。

"visualize the consequences of the actions"(I should know the result of the action I am about to take.)

The example is computation of a factorial function.(both in recursive process and iterative process)

# H7

## 流水账

- exer1.9
- exer1.10

# H8

## 流水账

- 重温 chap1.1.2

## 想法

因为我在做题的时候感觉还是有点吃力，感觉不舒服，而这的原因在于我的“基础不够扎实”。因此我想再从头学习，这次的目的就是将基础弄的足够扎实。让我思维行进的时候充满安全感。

# H9

## 流水账

- 重温 chap1.1.3-1.1.5

## 想法

```scheme
; 手写了一次 evaluate 过程
; 从最左最外开始，逐渐先把树构造出来
; 然后对树中的？进行运算，因为最外面的节点是确定的，因此可以逐步算出来所有节点的值，于是可以得到整个expression的值
; eval 结束
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

eval 的方式本身就和语言的语法关系非常密切。

而 lisp 的语法非常简单，一个 general rule 和几个 special rule 便足够。

目前又增加了“声明函数”的功能，且利用 substitution model 可以去手动 interprete 一个程序。

# H10

## 流水账

- chap1.1 全部重温完毕

## 想法

目前学到的就是从 math expression 转换为 program expression(scheme expression)

算是把 scheme 中最基础一部分的语法以及对应 eval 有更加详细的理解。

当我非常明确某个语法的各个细节的 eval，那么我使用的时候就不会轻易出错，更不会出现思维模糊混乱，最多也就是想不出来办法，而这是另外的问题。

# H11

## 流水账

- 重温 chap1.2.1

## 想法

对 linear 的 recursion 和 iteration 有更直观的感觉了吧。。

**感觉自己确实是在思考，只是这时间真的是刷刷的溜走...**

# H12

## 流水账

- 重温 chap1.2.2

- exer1.11

## 想法

虽然例子比较简单，习题也同样。但是，如果不用正确的思考方式，看这些做这些，对我的提升也比较小。

正确的思考方式是，将问题成功拆解为一些小问题，而将这些小问题利用自己所掌握的一一实现，最终实现了原问题。

然后，将之变得“自然直观”，掌握之。

也因此，这一个小时，我也没法全面掌握 tree recursion，因此没法继续往下走。

# H13

## 想法

其实这个小时我是在自己不看课本的总结，只是总是因为感觉自己进度太慢的原因，不想将这一个小时作数。

还是记上吧。。。毕竟是集中时间在思考 sicp 的主题

# H14

## 流水账

- exer1.12

## 想法

为什么进度这么慢？，因为我意识到了我基础的问题，并针对调整我的学习方式。

像数学等等领域，基础足够扎实尤其重要。即，对用于组成当前问题的“更微观一点的问题”的掌握要足够好。

不过确实，其实这里依然是有「思维陷阱」的，就像海淀驾校老师跟我们说的，“寻思可以，但别寻思的太多太深”。寻思多了反而在有限的时间内可能取得的结果反而不够好，尽管这里确实可能潜藏着什么道理规律。

「打基础」就是慢，如果进展顺利的话，与「囫囵吞枣」的策略相比是“先慢后快”，而且“上限高很多”（甚至猜测这个上限受灵感/自己的寿命限制，如果寿命悠久一直这么扎实的积累下去。。。）

当然随着生活/学习的不断进行，基础也会不断的被「优化」，变得更加优秀可靠牢固。

**学习不是旅游打卡，不是说看完、做完就拉倒，而是真的要 “掌握”。**

**没有吸收，仅仅有种熟悉感，大多数时候约等于没用，也就意味着这段时间基本浪费掉了**

### exer1.13(TODO)

我的思路是通过相减小与 0.5，但是问题在于是无穷的，所以是不行的

题目的提示，就算我最后证明了那个，又和题目是什么关系...?

# H15

## 流水账

- chap1.2.3

## 想法

chap1.2.3

order of growth is about the size of the input, the steps that required to solve this problem, and the space that needed when the size of the input grows.

看了一些 chap1.2.2 上面的 example（因为 exer1.14 基于这个，之前因为是英文应用题，没看..）

所以说，其实这些算法/计算问题，首先应该是讲问题定义清楚，然后思考清楚将至洞察找到计算的方向，然后将方向从模糊到具体实现，写成 recursive 的代码让计算机去“遍历所有可能性”。

将某金额破开，一共有五种可用的面额。通过**观察和思考**得出方案，那可能存在的情况可以看作是两者相加，一是不用某一种面额破开的可能性数量加上，一定必须要用某一种面额将至破开的所有可能性（而这又等于用一次这种面额，将剩余的金额再用 5 种破开）。然后沿着此方向下去，最终会到特殊情况，比如 0 种面额，0 金额甚至负数，这些特殊情况可以直接得出一个值，将这些值“归”回去，结果可得。

# H16

**暂时略过** chap1.2.4 - 1.2.6。这几章讲算法指标，以及一些例子和习题，等我具体学习算法的时候，参考着再看。

**暂时略过** chap1.3

## 流水账

浏览 chap1.3

## 想法

十多分钟就能过完 chap1.3 整个子章节，它讲的内容我非常清楚，那就是“一个函数可以当作另一个函数的输入或者是输出，这个机制可以用来建立‘更高的抽象规则’”

chap1.3.1 先将相关性不那么高的细节省略，突出描述将函数作为输入的感觉

chap1.3.2 介绍 lisp 中相关的语法，从使用 lisp 的角度来扩展上一章

chap1.3.3 介绍这种机制的应用场景

chap1.3.4 再进行扩展，介绍返回一个函数的情况

每一个小 chap 都应该可以被积累为几个基本功，这样在日常编程就能用了

我不看前面 1.2.4 以后，是因为工作上确实用不上算法，而高阶函数，其实目前也是用不上的

所以，准确来说，应该是**概念我都懂得一些，但是没有关于这些概念的非常踏实牢固的积累**，导致自己写代码时灵时不灵。

# H17

## 流水账

看完目录和所有章节的序言

## 想法

“感觉自己学习速度太慢了”这个想法一直折磨着我，导致我这个小时在读目录（似乎将目录都读完能等于某种意义上将这本书读完一样）

不过，还有一个好消息：我终于能将目录上，以及每章节的序言都“读懂”了。虽然和第一章类似，对各个具体情况没有详细掌握，但是高层次的概念和道理都是很明确的。

chap1 介绍编程语言最基本的元素，以及基础的 eval 模型（substitution model）。介绍“过程抽象”。介绍最常用的模式（iter recurse）。介绍程序复杂度分析(order of growth)。介绍一个强力语言特性，高阶函数。

chap2 介绍“数据抽象”，从简单数据变成了复杂的数据。

chap3 介绍“基于对象”和“基于流”的两种“编程思想”

chap4 转变角色为设计语言、实现语言特性的人。利用 scheme 提供的 meta lang 的特性

chap5 虽然 lisp 很灵活，但毕竟还是有一些限制。本章深入更底层，抽象并实现一个指令执行机器

# H18

## 流水账

进行一次总结

## 想法

使用编程语言“书写”源代码，是写给某另一个程序“看”的。

# H19

## 流水账

- chap1.2.2-example
- exer1.14

## 想法

自己思维应该能够使用 substitution model 去 evaluate expression

# H20

## 流水账

- exer1.15

## 想法

1.2 章的重点常见的“套路”，以及 order of growth

我应该学到：对代码能够 visualize 的能力。基于这个能力，还应再学到评估当前程序的 order of growth。

计算同样的结果，使用的算法不同，order of growth 就可能不同。比如 recursion 和 iteration 两种方式去计算 n!

设计整体代码的时候，可以先定义明确一个过程的输入、输出，以及这个过程“是做什么的”。当前，暂不需要考虑里面怎么实现。由于每个过程都如此的定义清晰了，那么这些过程之间应该可以组合，体现出更宏观的作用，乃至实现目标。

# H21

## 流水账

- chap1.3.1

## 想法

`(define (cube x) (* x x x))` is an abstraction that can calculate the cube of any number.

"Sigma notation" in math is an analogy to a higher order procedure.

从 sigma notation 再进一步，到 积分 notation

**higher order procedure = "template" + "slots"**

# H22

## 流水账

- chap1.3.2

## 想法

scheme 中，【声明】是一个关键词(define)，不像是 js(function, var, let...)。到这章节，加入了 lambda 形式，因此

```scheme
(define (someProcedure a) (+ a 1))

(define someProcedure (lambda (a) (+ a 1))); 相当于将直接define声明函数，“拆分”开两部分，“名字”和“其余部分”

((lambda (a) (+ 1 a)) 1); scheme的【匿名函数自执行】写法
```

学到了 let 语法的由来。原来是 lambda 的一个使用场景（local variables）下的语法糖（通过使用 let 形式，和正常写数学式子更像）。

自己过了几遍例子。

学会了一种写法形式，比如：`<body(斜体)>（高尖括号）`，代表着：“作用是 body”

# H23

## 流水账

- 浏览完 chap1.3

## 想法

可以看出，书中 chap 里，使用了大量篇幅去描述一个个【例子】。

多数情况下的文章结构：先 overview，然后讲一个“道理”，然后举对应的“例子”。

也就是说，我不仅仅需要理解记忆道理，还需要对例子也理解记忆。例子体现了“道理是如何被应用的”。

如果，对应某道理，我已经有了“自己的例子”，那么不去记忆作者给的似乎没有问题。

# H24

## 流水账

- chap2.1.1

## 想法

我发现这本书的章节序言都是会先写前面的总结，然后再写接下来的概览。就像是已经声明过的 procedure 一样，有时候会直接使用之前章节讲过的东西。

wishful thinking: 先定义清楚抽象数据以及其接口，不需要考虑其实现。以此为基础，思考更高层的操作这个抽象数据的方法。

使用 pair 实现（即封装 cons, car, cdr），也因此，这个数据是 list-structured

在更高层面的代码中，直接使用上面封好的有理数四则运算 procedure，以及直接将有理数这个抽象数据作为参数。

# H25-27

做题多，见识广，当然是大好事。

然而，“多”的前提是“每一个都足够精”。否则这些“量”不过是“空中楼阁”，是“景点打卡”，甚至是“发生在我身上的‘别人’（稀里糊涂）的故事”。

如果，我自己难以“利用”这段“经历”，那么其“价值”就小得多了。

## 流水账

- chap 1.1.2 的 example：counting change
- 具体的过程我是手写的，记在了我的 GootNotes 里

## 想法

一道题里面其实蕴含了“很多细节点”，每个细节点都弄清楚，整个题才算是清楚了。

慢，但是真的在“踏实的”成长。

model（动词）：编程是对“世界的某些部分”的某种“建模”。做一道题，我写的程序也是对题目所描述的问题的建模。（其中就包括很重要的一点，“代表”）

### 方法论

应该先自己去尽量尝试做，然后做到“足够”之后，才看答案。

自己做的过程中，应该有条理（基于自己的「积累」），而不是胡乱尝试。这样，思考的过程就会留下固定的思路。而当看答案的时候，就可以和自己的思路对比，找到自己思维中的问题，和提升的点，然后自己的「积累」就更多了一点。

最终达到，“似乎是”，没有看答案，就自己从头把问题做出来了的「经历」（这才是“参考答案”的正确使用方法）。

# H28

## 流水账

- 回看 1.1.7 newton's method for sqrt

## 想法

定义 = body(包括 arguments 的定义) + name

根号 x，不过是(define (sqrt x) (...))的另一种写法

过程体中书写其他的过程。可以通过“自调用”的方式，实现迭代处理。

“两数相加除以二”是体中的描述，也可以利用其抽象，“average”（名词做动词，表示求 average 的过程。或者说，这个过程的结果是 average）

# H29

## 流水账

- chap2.0

## 想法

### 1

值的一种“形式”是执行的某个过程，比如 `(+ 2 1)`

一个东西可以拆分为多个来表示，比如书中的例子，有理数可以拆分为“得出这个有理数的分子的过程”以及“得出这个有理数分母的过程”。因为一个过程的执行表示的是一个值，而一个有理数被拆分为两个值来表示，所以就需要两个过程了。

使用有理数，显然是将其当作一个概念的，然而如果用上述方式，每次使用有理数，需要使用两个概念。就很反人类思维了。因此，需要一个办法，形成 compound data，这样就可以和思维一样，当作一个东西去使用了。

而实现这个的机制的基础就是 scheme 提供的 list/pair 相关数据结构和方法。

### 2

我只用过 js，然而其实有个很重要的思维模式是 jser 不常有的，那就是使用某个过程/函数的时候，应该清楚的知道这个过程的参数的数据类型。（之所以没有这个习惯，是因为大多数普通场景中，js 作为动态语言，自带的各种操作符/函数不“挑食”，无论传入什么玩意，都能给出来一个结果）

比如，sicp 中此处举例，+ 只能传入普通数，而不能传入有理数。

使用 cons car cdr 起到“胶水”作用，将分子分母粘在一起作为一个整体。其实，这个过程也涉及到了“代表”。就像是，我们用 1 代表 true，用 0 代表 false 一样。至少关于这个“目标”的这个“本质”上，它们是一致的，只是“形式”不同。（有理数不是 scheme 的 native 级别支持，而 pair 则是 native 支持，因此可以来用后者实现前者）

### 3

有上文的描述可知，一个 compound data 一定应该有两种方法，一种是将相关的部件组成整体的（constructors），另一种是从这个整体获取某个部件的方式（selectors）。而这两部分统称为此数据类型的“接口”（interface）

# H30

## 流水账

- chap2.1.1: Example Arithmetic Operations of National Numbers

## 想法

目标确定了，自己先尝试实现。

# H31

## 流水账

- chap2.1.1-2.1.3

## 想法

发现 define 还能这么用，我一直以为 body 只能是一个 expression 呢，题中给的例子明显是多个，也是附和 js 的 eval 顺序（上下内外左右）

```scheme
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
```

Figure 2.1（Data-abstraction barriers in the rational- number package.） 终于看懂了（大半年之前看的时候感觉很模糊）

In general, we can think of **data** as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.

# H32

## 流水账

- chap2.2.0

## 想法

H31 中看到的 data 的定义让我深受震撼。将几个相关的“过程”分为一组，这些过程都与这个“数据”（数据类型）有关（作为参数，或者作为输出），把这一组叫做“接口”。（目前来说，一个数据对应一个接口）

另外，更好的体会到了“语言层面的 native”。以上面的例子来说，语言提供了 `cons` 的过程，以及可以组合 compound procedure 的 mechanism，这样才能将“更宏观的积木搭起来”。（有些语言机制能用现有的实现出来，有些则不能。比如 sicp chap5 讲的 scheme 语言本身的限制）

compound data 不过是将一堆 primitive data 粘在了一起，然后提供高抽象层的 api 来操作这种数据类型。然而在高层 api 的内部，依然是需要使用低层过程，这样不断降低抽象层，最终到 primitive procedure。

而类比来说，一个人的“primitive procedure”可以认为是“基础知识/常识”和“基本功”。平时做事可以类比为执行过程，而思维中不同的内容也对应着不同抽象层中的数据和过程。

不断的去体会编程中的“精确”。或许像「乐器」一样，当踏实的掌握了足够的“精确级别”的东西之后，才是表达“个人风格”这种更高级的时候。

### box-and-pointer notation

```scheme
; 当被eval的时候，这是一个执行的过程
; 执行的结果是可以使用这种 notation 来形式化（或者说用另一种形式来表达）
; 其实使用这种 notation 也是在“执行”（一笔一笔的画出来）
; 所以，代码表达的是“怎么做”，做的结果在计算机内部不能被人直接看见，而使用这种notation画的结果可以直接看得到（但是不能被计算机直接运行或者使用）
(cons 1
  (cons 2
    (cons 3
      nil)
  )
)

; 从这里也可以看到eval代码中的一部分时候发生的
; 当 eval 1 的时候，直接使用 “符号1” 对应的这种数据类型的这个值
; 当 eval n 的时候，先从这个 n 对应的 env 中找到其值，然后再经历上面一行的过程。

; 体会一下，两个eval出来是一样的表达式
(list 1 2 3) ; 经历这个过程
'(1 2 3) ; 字面量是语法糖，是一个过程的结果

```

另外一个很震撼的想法是，闭包在 jser 中是很特殊的存在（似乎是怎么都没有办法完美把握的概念），尤其是我们非科班的 jser。而这里提到，closure 是 operation（属于 procedure） 的一种 property，
cons 就具有这种 property（an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation）。

与 closure 相关的还有个概念 hierarchical structures

# H33

## 流水账

- chap2.2
- 一些思考和整理（放在 goodnotes 上了）

## 想法

2.2 后面讲解了大量的常用 util 函数，比如 map、filter 等的实现及其作用。（合适的时候都研究一边，然后形成对应的思维）

然后用一个大的例子将整个目前的内容穿在一起，之后总结和深化了程序设计方法论。

讲解了 stratified design（宏观微观）。不同的层级提供不同的供更上层来使用的 primitive。在每个 level 中的直观感觉是不一样的，因为能使用的是本层的概念。对于实现同样的新功能，可实现的每一层的具体修改方案是不同的。

# H34

## 流水账

- chap3.1.1

## 想法

仅仅是 chap1 chap2 的抽象还不够，还需要“一种能将整个代码从整体分为一块块”的机制（模块内紧密耦合，模块间松耦合）

这里，一块就是一个 object（computing object），它拥有 state

两个特殊语法：set! 和 begin

讲解了一个 bank account 的例子，返回一个函数。（a 和 getA() 其实或许只是形式上的不同）

scheme 中的 symbol 和 js 的 string 究竟有多大的区别？？（从使用来说，感觉基本一致的）
