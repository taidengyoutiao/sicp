# H1

重温 SICP

看了一下目录前言等。（chap1 讲 procedure、chap2 讲 data、chap3 讲模块以及内部状态）

翻了翻第一章（从基本的 scheme 语法，到递归，到高阶函数。中间用了几个例子和几十道习题）

仔细看了一下 1.1 章节

# H2

evaluate(someExpression)

<. <the result>

exercise 1.1 - 1.5

项目上传 github

# H3

学了一部分 chap1.6

# H4

自己用 cond 实现 if，暂时没弄明白 exer1.6 的问题在哪里 🧐

exer1.7 做了一半，前面的问题还没有思考的很透彻

# H5

完成 exer1.8

看了一半 chap1.8

状态不太好，看着教材思路总是乱跑，不怎么产生理解

# H6

看完 1.2, 1.2.1

本章讲解一些常见的“套路”，以及对应的时空复杂度。

"visualize the consequences of the actions"(I should know the result of the action I am about to take.)

The example is computation of a factorial function.(both in recursive process and iterative process)

# H7

exer 1.9

exer 1.10

# H8

从头开始看。。。看到 chap1.1.2

因为我在做题的时候感觉还是有点吃力，感觉不舒服，而这的原因在于我的“基础不够扎实”。因此我想再从头学习，这次的目的就是将基础弄的足够扎实。让我思维行进的时候充满安全感。

# H9

chap1.1.3

```scheme
; 手写了一次 evaluate 过程
; 从最左最外开始，逐渐先把树构造出来
; 然后对树中的？进行运算，因为最外面的节点是确定的，因此可以逐步算出来所有节点的值，于是可以得到整个expression的值
; eval 结束
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

eval 的方式本身就和语言的语法关系非常密切。

而 lisp 的语法非常简单，一个 general rule 和几个 special rule 便足够。

读完了 chap1.1.5

目前又增加了“声明函数”的功能，且利用 substitution model 可以去手动 interprete 一个程序。

# H10

目前学到的就是从 math expression 转换为 program expression(scheme expression)

chap1.1 复习完毕了。算是把 scheme 中最基础一部分的语法以及对应 eval 有更加详细的理解。

当我非常明确某个语法的各个细节的 eval，那么我使用的时候就不会轻易出错，更不会出现思维模糊混乱，最多也就是想不出来办法，而这是另外的问题。
