# procedure thinking

是编程的本质。是一套思维方法，因此是人使用自己思维的方式。编程能力是思维能力的延伸。

这套思维方法是基础的，然而它依赖与“更为基础”的东西，它是：「记忆、识别」（明确、固定性质）（觉是固定的，不能今天看红色是一个感觉，明天又是另外一个感觉）。不管是 data 还是 procedure，不管是 primitive 还是 compound，不管是 common form 还是 special form，形成了之后都是不变的。

它包括：primitive data/procedure（常识基本功）, combination & naming（定义）, abstraction（抽象）, modular（模块与系统环境）

## 选择 & 忽略

观察问题，思维选择哪些细节又忽略哪些细节。

## 代表 & 解读

人具有联想能力。举个例子，对于人来说，数字 1 不仅仅是它本身，它可以“代表”很多，它可能是“一个苹果”也可能是“一个对象”、“一分”“一秒”、“一次”等等

## 归纳 & 演绎

寻找“多个”存在之间的「共性」 -> 将这个共性「提取」成“一个”并「塑形」 -> 作为一个“整体/黑盒”直接使用

对于同一个问题，可能存在多种实现方式，能在高抽象层解决的问题，就可以不在低层调整。合理的 abstraction barrier 的设定是很重要的。

## 分解 & 组合

掌握“模型”，面对着无穷多的问题，要能利用上“精华”，以此为基础，组合一些具体内容，形成方案。

接口，像积木一样可以相互拼装

## 模块化（黑盒）

实现完成的代码，应该形成一个个模块（内部紧密耦合，外部松耦合）（只需要把握“输入”与“输出”的模式，而不需要考虑其“内部结构”）（比如，按红色按钮停止，按绿色按钮启动，不需要知道从按按钮到机器状态的改变究竟是怎么回事，只需要知道，“做什么以及其后果”就行了）。
。

这就要求实现“之前先”做好模块设计（这个模块应该具有什么能力，其他部分如何使用它），否则一个模块不能提供“合理的交互方式”，也是白给。（按红灯机器运行，过了一会，按红灯机器又停止。换句话说，人不能轻易的掌握这里的规律，不知道自己能怎么操作，以及对应的后果）

一个模块的内部可以有多种实现的可能性。变换了实现，对于外部来说，其使用方式是不变的（可能质量变好、速度变快）
